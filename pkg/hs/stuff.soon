|^  %+  $cons
      ($odd-mr2 3)
    %+  $cons
      ($odd-mr2 2)
    %+  $cons
      ($odd-mr2 1)
    %+  $cons
      ($odd-mr2 0)
    0

  ::  TODO enforce types by checking bool-ness of `c`
  bool
    ~/  bool
    |=  (t f c)
    (c t f)

  true
    ~/  true
    |=  (t f)
    t

  false
    ~/  false
    |=  (t f)
    f

  not
    ~/  not
    |=  b
    ($bool $false $true b)

  dist      0
  const     1
  id        2
  compose   3
  flip      4
  seq       5
  enhance   6
  which     7
  incr      8
  fold-nat  9

  ignore
    ~/  ignore
    |=  (x y)
    y

  is-zero
    ~/  is-zero
    |=  (n)
    ($fold-nat ($const $false) $true n)

  none
    ~/  none
    |=  (n s)
    n

  some
    ~/  some
    |=  (x n s)
    (s x)

  option
    ~/  option 
    |=  (n s o)
    (o n s)

  decr
    ~/  decr
    |=  (n)
    %*  $fold-nat
      ($option ($some 0) ($compose $some $incr))
      $none
      n
    ==

  lef
    ~/  lef
    |=  (x f g)
    (f x)

  rit
    ~/  rit
    |=  (x f g)
    (g x)

  either
    ~/  either
    |=  (f g x)
    (x f g)

  cons
    ~/  cons
    |=  (x y f)
    (f x y)

  uncons
    ~/  uncons
    |=  (f x)
    (x f)

  car
    ~/  car
    |=  x
    ($uncons $const x)

  cdr
    ~/  car
    |=  x
    ($uncons $ignore x)

  add
    ~/  add
    |=  (x y)
    (9 8 x y)

  w2
    ~/  w2
    |=  (f x y)
    (f x y)

  fix
    %-  (6 2 %fix)
    %-  (0 2)
    %*  $w2
      ((0 (1 ((0 (1 (6 2 %fix))) (0 2)))) ((0 $w2) 2))
      ((0 (1 ((0 (1 (6 2 %fix))) (0 2)))) ((0 $w2) 2))
    ==

  fib-not-one
    ~/  fib-not-one
    |=  (fib n-minus-one n-minus-two)
    ($add (fib n-minus-one) (fib n-minus-two))

  fib-not-zero
    ~/  fib-not-zero
    |=  (fib n-minus-one)
    %*  ($decr n-minus-one)
      1
      ($fib-not-one fib n-minus-one)
    ==

  fib-rec
    ~/  fib-rec
    |=  (fib n)
    %*  ($decr n)
      0
      ($fib-not-zero fib)
    ==

  even
    ~/  even
    |=  n
    ($fold-nat $not $true n)

  odd
    ~/  odd
    |=  n
    ($fold-nat $not $false n)

  fib
    ~/  fib
    |=  n
    ($fix $fib-rec n)

  odd-loop
    ~/  odd-loop
    |=  (even odd n)
    %*  $option
      $false
      even
      ($decr n)
    ==

  even-loop
    ~/  even-loop
    |=  (even odd n)
    %*  $option
      $true
      odd
      ($decr n)
    ==

  loop-1-1-rec
    ~/  loop-1-1-rec
    |=  (f g rec x)
    %*  $either
      (f ($compose rec $lef) ($compose rec $rit))
      (g ($compose rec $lef) ($compose rec $rit))
      x
    ==

  loop-1-1
    ~/  loop-1-1
    |=  (f g x)
    ($fix ($loop-1-1-rec f g) x)

  even-rec
    ~/  even-rec
    |=  x
    ($loop-1-1 $even-loop $odd-loop ($lef x))

  odd-rec
    ~/  even-rec
    |=  x
    ($loop-1-1 $even-loop $odd-loop ($rit x))

  ::  evn-mr2-loop :: ((Nat -> Bool) -> Nat -> Bool)
  ::               -> (Nat -> Bool)
  ::               -> Nat
  ::               -> Bool
  evn-mr2-loop
    ~/  evn-mr2-loop
    |=  (rec odd n)
    ($even-loop rec ($fix odd rec) n)

  odd-mr2-loop
    ~/  odd-mr2-loop
    |=  (rec evn n)
    ($odd-loop ($fix evn rec) rec n)

  evn-mr2
    ~/  evn-mr2
    |=  n
    ($fix $evn-mr2-loop $odd-mr2-loop n)

  odd-mr2
    ~/  odd-mr2
    |=  n
    ($fix ($odd-mr2-loop $evn-mr2-loop) n)
==
